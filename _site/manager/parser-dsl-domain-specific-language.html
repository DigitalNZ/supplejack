<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width">

        <title>Supplejack : Parser DSL (Domain Specific Language)</title>
        <meta name="description" content="Documentation for the Supplejack stack">

        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.no-icons.min.css" rel="stylesheet">
        <link rel="stylesheet" href="/supplejack/css/syntax.css">
        <link rel="stylesheet" href="/supplejack/css/main.css">
    </head>
    <body>

        <div class="container">
            <div class=row-fluid>
                <div id=header class=span12>
                    <h4><a class=brand href="/supplejack/">Supplejack</a>
    <small>Documentation for the Supplejack stack</small>
</h4>


                </div>
            </div>

            <div class=row-fluid>
                
                
                    <div id=navigation class=span2>
                        <ul class="nav nav-list">
    <li><a href="/supplejack/">Home</a></li>
    
        
        

        
            
                <li class=nav-header>Getting started</li>
            
            <li data-order="2"><a href="/supplejack/start/install-setup.html">Install & Setup</a></li>
        
            
            <li data-order="1"><a href="/supplejack/start/dependancies.html">Dependancies</a></li>
        
            
            <li data-order="5"><a href="/supplejack/start/supplejack-worker.html">Supplejack Worker</a></li>
        
            
            <li data-order="4"><a href="/supplejack/start/supplejack-manager.html">Supplejack Manager</a></li>
        
            
            <li data-order="3"><a href="/supplejack/start/supplejack-api.html">Supplejack API</a></li>
        
    
        
        

        
            
                <li class=nav-header>Creating your API</li>
            
            <li data-order="1"><a href="/supplejack/api/api-admin.html">API Admin</a></li>
        
            
            <li data-order="2"><a href="/supplejack/api/schema-dsl-domain-specific-language.html">Schema DSL (Domain Specific Language)</a></li>
        
            
            <li data-order="1"><a href="/supplejack/api/creating-a-schema.html">Creating a Schema</a></li>
        
    
        
        

        
            
                <li class=nav-header>Using the manager</li>
            
            <li data-order="1"><a href="/supplejack/manager/introduction-to-parser-scripts.html">Introduction to parser scripts</a></li>
        
            
            <li data-order=""><a href="/supplejack/manager/parser-dsl-domain-specific-language.html">Parser DSL (Domain Specific Language)</a></li>
        
            
            <li data-order=""><a href="/supplejack/manager/validations.html">Validations</a></li>
        
            
            <li data-order=""><a href="/supplejack/manager/xml-namespaces.html">XML Namespaces</a></li>
        
            
            <li data-order=""><a href="/supplejack/manager/attribute-transformation-options.html">Attribute Transformation Options</a></li>
        
            
            <li data-order=""><a href="/supplejack/manager/enrichments.html">Enrichments</a></li>
        
            
            <li data-order=""><a href="/supplejack/manager/modifiers.html">Modifiers</a></li>
        
    
        
        

        
            
                <li class=nav-header>Developers</li>
            
            <li data-order="1"><a href="/supplejack/dev/licence.html">Licence</a></li>
        
            
            <li data-order="3"><a href="/supplejack/dev/changelog.html">Changelog</a></li>
        
    
<!-- List additional links. It is recommended to add a divider
    e.g. <li class=divider></li> first to break up the content. -->
</ul>

                    </div>

                    <div id=content class=span10>
                        <div class=page-header>
    <h1>Parser DSL (Domain Specific Language)
        
    </h1>
</div>

<h2 id="toc_0">Records source</h2>

<h3 id="toc_1">base_url</h3>

<p>The base_url method allows the operator to specify where to fetch the harvest resources from. It accepts a URL or a absolute path in disk. Additionally the operator can specify different urls/paths for each environment.</p>

<h3 id="toc_2">Web resource</h3>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">base_url</span> <span class="s2">&quot;http://gdata.youtube.com/feeds/api/videos&quot;</span>
</code></pre></div>
<h3 id="toc_3">Path</h3>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">base_url</span> <span class="s2">&quot;file:///data/sites/harvester/resources/nz_museum.xml&quot;</span>
</code></pre></div>
<h3 id="toc_4">Different paths per environment</h3>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">base_url</span> <span class="ss">staging</span><span class="p">:</span> <span class="s2">&quot;file:///data/sites/harvester/staging/nz_museum.xml&quot;</span>
<span class="n">base_url</span> <span class="ss">production</span><span class="p">:</span> <span class="s2">&quot;file:///data/sites/harvester/production/nz_museum.xml&quot;</span>
</code></pre></div>
<h3 id="toc_5">All the files in a directory</h3>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="no">Dir</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;/export/home/harvest/nlnzcat/updates/*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sort</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">filename</span><span class="o">|</span>
  <span class="n">base_url</span> <span class="s2">&quot;file://</span><span class="si">#{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">end</span>
</code></pre></div>
<h2 id="toc_6">Authentication</h2>

<h3 id="toc_7">basic_auth</h3>

<p>Allows to the operator to add HTTP Basic Authentication to all requests executed by the parser applied to it.  </p>

<p>The first string is the username and the second is the password.  </p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">basic_auth</span> <span class="s2">&quot;username&quot;</span><span class="p">,</span> <span class="s2">&quot;password&quot;</span>
</code></pre></div>
<p>This will basically append &quot;username:password&quot; to the URL&#39;s of the requests executed by this parser. So a request to: &quot;<a href="http://gdata.youtube.com/feeds/api/videos">http://gdata.youtube.com/feeds/api/videos</a>&quot; will be converted to &quot;http://username:<a href="mailto:password@gdata.youtube.com">password@gdata.youtube.com</a>/feeds/api/videos&quot;</p>

<h2 id="toc_8">Pagination</h2>

<h3 id="toc_9">paginate</h3>

<p>Allows the operator to paginate through a API and specify the name of the parameters used by the particular API as well as the values for those parameters.  </p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">base_url</span> <span class="s2">&quot;http://gdata.youtube.com/feeds/api/videos&quot;</span>
<span class="n">paginate</span> <span class="n">page_parameter</span><span class="p">:</span> <span class="s2">&quot;start-index&quot;</span><span class="p">,</span> <span class="ss">type</span><span class="p">:</span> <span class="s2">&quot;item&quot;</span><span class="p">,</span> <span class="n">per_page_parameter</span><span class="p">:</span> <span class="s2">&quot;max-results&quot;</span><span class="p">,</span> <span class="n">per_page</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="ss">page</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">total_selector</span><span class="p">:</span> <span class="s2">&quot;//openSearch:totalResults&quot;</span>
</code></pre></div>
<p>The above example will execute the following requests:  </p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">http://gdata.youtube.com/feeds/api/videos?start-index=1&amp;max-results=50
http://gdata.youtube.com/feeds/api/videos?start-index=51&amp;max-results=50
http://gdata.youtube.com/feeds/api/videos?start-index=101&amp;max-results=50  
etc...
</code></pre></div>
<p>The total_selector option is to extract the total amount of records so that the paginator knows when to stop.  </p>

<p>The type option refers to the weather the pagination is implemented by specifiying the starting index like in the above case where you need to specify &quot;item&quot; or the case where you specify the actual page value, for this case use the value &quot;page&quot;.  </p>

<h2 id="toc_10">Reject records</h2>

<h3 id="toc_11">reject_if</h3>

<p>The operator can use the reject_if directive to reject records which match the criteria specified.  </p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">reject_if</span> <span class="k">do</span>
  <span class="n">get</span><span class="p">(</span><span class="ss">:title</span><span class="p">)</span><span class="o">.</span><span class="n">find_with</span><span class="p">(</span><span class="sr">/Weekly Review/</span><span class="p">)</span><span class="o">.</span><span class="n">present?</span>
<span class="k">end</span>
</code></pre></div>
<h2 id="toc_12">Delete records</h2>

<h3 id="toc_13">delete_if</h3>

<p>The operator can use the delete_if directive to mark records as deleted in the api which match the criteria specified.  </p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">delete_if</span> <span class="k">do</span>
  <span class="n">get</span><span class="p">(</span><span class="ss">:title</span><span class="p">)</span><span class="o">.</span><span class="n">find_with</span><span class="p">(</span><span class="sr">/Weekly Review/</span><span class="p">)</span><span class="o">.</span><span class="n">present?</span><span class="sb">`</span>
<span class="sb">end  </span>
</code></pre></div>
<p>When the block of code returns a true value the record will be marked as deleted in the API. In the particular case above all records with a title that matches &quot;Weekly Review&quot; will be deleted.  </p>

<h2 id="toc_14">Throttling</h2>

<h3 id="toc_15">throttle</h3>

<p>To throttle the requests to a specific host add a throttle directive to the parser configuration.  </p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">TestParser</span> <span class="o">&lt;</span> <span class="no">HarvesterCore</span><span class="o">::</span><span class="no">Xml</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">throttle</span> <span class="ss">:host</span> <span class="o">=&gt;</span> <span class="s2">&quot;gdata.youtube.com&quot;</span><span class="p">,</span> <span class="ss">:delay</span> <span class="o">=&gt;</span> <span class="mi">10</span>
<span class="k">end</span>
</code></pre></div>
<p>The effect of the throttle directive above will be that requests to the gdata.youtube.com host will be at least 10 seconds apart from each other.  </p>

<p>Fractions of a second are also allowed for finer grained control.</p>

<h2 id="toc_16">Request timeout</h2>

<h3 id="toc_17">request_timeout</h3>

<p>To change the length of time that the harvester will wait before timing out a request you can do the following:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">TestParser</span> <span class="o">&lt;</span> <span class="no">HarvesterCore</span><span class="o">::</span><span class="no">Xml</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">request_timeout</span> <span class="mi">60000</span>
<span class="k">end</span>
</code></pre></div>
<p><em>Note:</em> The time is in milliseconds, so the above example will set a request timeout of 60 seconds</p>

<h2 id="toc_18">Harvesting non-primary sources</h2>

<h3 id="toc_19">priority</h3>

<p>By defining a priority, the harvest operator indicates that this parser will not overwrite the primary source, but will create an additional source on the record with a matching internal identifier. The priority is a positive or negative integer, a value of 0 will disable this feature (overwrite the primary source).</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">priority 5
</code></pre></div>
<p>Unintuitively, sources with more negative priorities are used first, and more positive priorities are used last. This could also be expressed as higher priorities are lower priority.</p>

<h2 id="toc_20">XML Specific</h2>

<h3 id="toc_21">Record Selector</h3>

<p>When the source of the records is in one big XML file it is necessary to split the document into XML fragments that represent each record.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">TestParser</span> <span class="o">&lt;</span> <span class="no">HarvesterCore</span><span class="o">::</span><span class="no">Xml</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">record_selector</span> <span class="s2">&quot;//item&quot;</span>
<span class="k">end</span>  
</code></pre></div>
<p>The &quot;//item&quot; string represents the xpath that will split the XML file.</p>

<h3 id="toc_22">Sitemap Entry Selector</h3>

<p>In cases where the base_url points to a sitemap, the operator can specify the xpath that matches each URL in the sitemap.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">TestParser</span> <span class="o">&lt;</span> <span class="no">HarvesterCore</span><span class="o">::</span><span class="no">Xml</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">sitemap_entry_selector</span> <span class="s2">&quot;//loc&quot;</span>
<span class="k">end</span>  
</code></pre></div>
<p>The most common use case for this is sitemaps and the typical node where sitemaps store the URL is a node.</p>

<h3 id="toc_23">Record Format</h3>

<p>When harvesting from a sitemap the most common case is that the resources specified in the sitemap are HTML web pages, but there are cases when they are XML.</p>

<p>For these cases it is necessary to specify what is the format of the web resources.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">NzOnScreen</span> <span class="o">&lt;</span> <span class="no">HarvesterCore</span><span class="o">::</span><span class="no">Xml</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">sitemap_entry_selector</span> <span class="s2">&quot;//loc&quot;</span>
  <span class="n">record_format</span> <span class="ss">:xml</span><span class="sb">`</span>
<span class="sb">end  </span>
</code></pre></div>
<h3 id="toc_24">Multiple Records from multiple Sitemap entries</h3>

<p>Sometimes a sitemap_entry_selector will specify a location that specifies multiple records, in this case you will need to use all 3 of the above attributes in conjunction with each other, for example:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">NzOnScreen</span> <span class="o">&lt;</span> <span class="no">HarvesterCore</span><span class="o">::</span><span class="no">Xml</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">sitemap_entry_selector</span> <span class="s2">&quot;//loc&quot;</span>
  <span class="n">record_selector</span> <span class="s2">&quot;//feed//entry&quot;</span>
  <span class="n">record_format</span> <span class="ss">:xml</span><span class="sb">`</span>
<span class="sb">end  </span>
</code></pre></div>
<p>In this instance the sitemap entries are nodes. At each location specified by a sitemap entry there are multiple record entries which can be selected by specifying the record_selector. In this instance the expected format of the records entries is XML.</p>

<h3 id="toc_25">Namespaces</h3>

<p><em>See XML Namespaces</em> --  link to namepaces page soon</p>

<p>The harvest operator can define namespaces at the class level. This allows the operator to then specify which namespace it wants to use for specific xpath queries.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">NzOnScreen</span> <span class="o">&lt;</span> <span class="no">HarvesterCore</span><span class="o">::</span><span class="no">Xml</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">namespaces</span> <span class="ss">dc</span><span class="p">:</span> <span class="s2">&quot;http://purl.org/dc/elements/1.1/&quot;</span>
  <span class="n">attribute</span> <span class="ss">:category</span><span class="p">,</span> <span class="ss">xpath</span><span class="p">:</span> <span class="s2">&quot;//dc:identifier&quot;</span>
<span class="k">end</span>
</code></pre></div>
<h3 id="toc_26">Node</h3>

<p>Sometimes the data will contain groups of tags which relate to each other. For example a number of authors, each with a first name and last name. In this case the harvest operator can select the group node and then access the children in a block.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">attribute</span> <span class="ss">:contributor</span> <span class="k">do</span>
  <span class="n">contributor</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="ss">:contributor</span><span class="p">)</span>

  <span class="n">node</span><span class="p">(</span><span class="s2">&quot;//person&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">node</span><span class="o">|</span>
    <span class="n">contributor</span> <span class="o">+=</span> <span class="n">compose</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s2">&quot;first-name&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s2">&quot;last-name&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">contributor</span>
<span class="k">end</span>  
</code></pre></div>
<p>If you are wanting to use predefined namespaces inside of a node block you will need to add self._namespaces to all your xpath method calls. This is because within the node block the node is just a nokogiri element.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">node</span><span class="p">(</span><span class="s2">&quot;./metadata/m:record/m:datafield[@tag=&#39;260&#39;]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">node</span><span class="o">|</span>
  <span class="n">text</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s2">&quot;./m:subfield&quot;</span><span class="p">,</span> <span class="nb">self</span><span class="o">.</span><span class="n">_namespaces</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:text</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;; &quot;</span><span class="p">)</span>
<span class="k">end</span>  
</code></pre></div>
<h2 id="toc_27">OAI Specific</h2>

<p>(this line seems wrong - the default OAI implementation should not specify a &quot;set&quot; at all)</p>

<p>By default, the OAI implementation uses &amp;metadataPrefix=oai_dc with no set value, but these can be configured on a per-parser basis, as below:</p>

<h3 id="toc_28">MetadataPrefix</h3>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">base_url</span> <span class="s2">&quot;http://emu.tepapa.govt.nz/oai/oai.php&quot;</span>
<span class="n">metadata_prefix</span> <span class="s1">&#39;oai_dc_mm&#39;</span>
</code></pre></div>
<h3 id="toc_29">Set</h3>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">base_url</span> <span class="s2">&quot;http://emu.tepapa.govt.nz/oai/oai.php&quot;</span>
<span class="n">set</span> <span class="s1">&#39;CEISMIC&#39;</span>
</code></pre></div>
<h2 id="toc_30">JSON Specific</h2>

<h3 id="toc_31">Record Selector</h3>

<p>When there are many records in one JSON file, it is necessary to select the array containing records.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">TestParser</span> <span class="o">&lt;</span> <span class="no">HarvesterCore</span><span class="o">::</span><span class="no">Json</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">record_selector</span> <span class="s2">&quot;$.items&quot;</span>
<span class="k">end</span>  
</code></pre></div>
<p>This is a JsonPath expression that selects the array. If the root of the file is an array, you would use &quot;$&quot;</p>

<h3 id="toc_32">Paths</h3>

<p>Attributes are selected within each record using JsonPath</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">attribute</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">path</span><span class="p">:</span> <span class="s2">&quot;$.title&quot;</span>
<span class="n">attribute</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">path</span><span class="p">:</span> <span class="s2">&quot;$.author.name&quot;</span>  
</code></pre></div>
<p>See <a href="http://goessner.net/articles/JsonPath/">http://goessner.net/articles/JsonPath/</a> for more details on JSON path.</p>

<p>Note: JSON key names containing special characters like : and similar should be surrounded in &#39;single quotes&#39;, even if they are the old thing in the path. For example:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">attribute</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">path</span><span class="p">:</span> <span class="s2">&quot;&#39;dc:title&#39;&quot;</span>
<span class="c1"># or</span>
<span class="n">attribute</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">path</span><span class="p">:</span> <span class="s2">&quot;$.&#39;dc:title&#39;&quot;</span>
</code></pre></div>

                    </div>
                
            </div>

            <div class=row-fluid>
                <div id=footer class=span12>
                    Documentation for <a href="https://github.com/DigitalNZ/supplejack_api">Supplejack</a>

                </div>
            </div>
        </div>

        <script>
            function orderNav() {
                var list,
                    section,
                    header,
                    sections = [],
                    lists = {},
                    headers = {};

                var navUl = document.querySelectorAll('#navigation ul')[0],
                    navLis = document.querySelectorAll('#navigation ul li');

                if (!navUl) return;

                for (var i = 0; i < navLis.length; i++) {
                    var order, li = navLis[i];

                    if (li.classList.contains('nav-header')) {
                        section = li.textContent || li.innerText;
                        sections.push(section);
                        headers[section] = li;
                        continue;
                    }

                    if (!lists[section]) {
                        lists[section] = [];
                    }

                    order = parseFloat(li.getAttribute('data-order'))
                    lists[section].push([order, li]);
                }

                for (var i = 0; i < sections.length; i++) {
                    section = sections[i];
                    list = lists[section].sort(function(a, b) {
                        return a[0] - b[0];
                    });

                    if (header = headers[section]) {
                        navUl.appendChild(header);
                    }
                    for (var j = 0; j < list.length; j++) {
                        navUl.appendChild(list[j][1]);
                    }
                }
            }

            if (document.querySelectorAll) orderNav();
        </script>
    </body>
</html>
