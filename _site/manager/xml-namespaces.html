<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width">

        <title>Supplejack : XML Namespaces</title>
        <meta name="description" content="Documentation for the Supplejack stack">

        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.no-icons.min.css" rel="stylesheet">
        <link rel="stylesheet" href="/supplejack/css/syntax.css">
        <link rel="stylesheet" href="/supplejack/css/main.css">
    </head>
    <body>

        <div class="container">
            <div class=row-fluid>
                <div id=header class=span12>
                    <h4><a class=brand href="/supplejack/">Supplejack</a>
    <small>Documentation for the Supplejack stack</small>
</h4>


                </div>
            </div>

            <div class=row-fluid>
                
                
                    <div id=navigation class=span2>
                        <ul class="nav nav-list">
    <li><a href="/supplejack/">Home</a></li>
    
        
        

        
            
                <li class=nav-header>Getting started</li>
            
            <li data-order="2"><a href="/supplejack/start/install-setup.html">Install & Setup</a></li>
        
            
            <li data-order="1"><a href="/supplejack/start/dependancies.html">Dependancies</a></li>
        
            
            <li data-order="5"><a href="/supplejack/start/supplejack-worker.html">Supplejack Worker</a></li>
        
            
            <li data-order="4"><a href="/supplejack/start/supplejack-manager.html">Supplejack Manager</a></li>
        
            
            <li data-order="3"><a href="/supplejack/start/supplejack-api.html">Supplejack API</a></li>
        
    
        
        

        
            
                <li class=nav-header>Creating your API</li>
            
            <li data-order="2"><a href="/supplejack/api/schema-dsl-domain-specific-language.html">Schema DSL (Domain Specific Language)</a></li>
        
            
            <li data-order="1"><a href="/supplejack/api/creating-a-schema.html">Creating a Schema</a></li>
        
    
        
        

        
            
                <li class=nav-header>Using the manger</li>
            
            <li data-order="1"><a href="/supplejack/manager/introduction-to-parser-scripts.html">Introduction to Parser scripts</a></li>
        
            
            <li data-order=""><a href="/supplejack/manager/parser-dsl-domain-specific-language.html">Parser DSL (Domain Specific Language)</a></li>
        
            
            <li data-order=""><a href="/supplejack/manager/validations.html">Validations</a></li>
        
            
            <li data-order=""><a href="/supplejack/manager/xml-namespaces.html">XML Namespaces</a></li>
        
            
            <li data-order=""><a href="/supplejack/manager/attribute-transformation-options.html">Attribute Transformation Options</a></li>
        
            
            <li data-order=""><a href="/supplejack/manager/enrichments.html">Enrichments</a></li>
        
            
            <li data-order=""><a href="/supplejack/manager/modifiers.html">Modifiers</a></li>
        
    
        
        

        
            
                <li class=nav-header>Developers</li>
            
            <li data-order="1"><a href="/supplejack/dev/licence.html">Licence</a></li>
        
            
            <li data-order="3"><a href="/supplejack/dev/changelog.html">Changelog</a></li>
        
    
<!-- List additional links. It is recommended to add a divider
    e.g. <li class=divider></li> first to break up the content. -->
</ul>

                    </div>

                    <div id=content class=span10>
                        <div class=page-header>
    <h1>XML Namespaces
        
    </h1>
</div>

<p>Many XML, RSS and OAI sources we harvest make use of XML Namespaces. Understanding namespaces and using them correctly is important to make parsers behave predictably.
Theres a lot of material online for a complete definition of what namespaces are an how to use them, this page describes some of the specifics that will make writing parsers easier.</p>

<h3 id="toc_0">Namespace basics</h3>

<ul>
<li>XML documents can contain elements (like a <code>&lt;title&gt;</code>) from different vocabularies. For example a <code>&lt;title&gt;</code> of a book may have a different meaning that a <code>&lt;title&gt;</code> of a person.</li>
<li>Namespaces are used to make an element (like a <code>&lt;title&gt;</code>) specific by adding a unique identifier to them.</li>
<li>The Namespace Name (the unique identifier) is normally a URI</li>
<li>In XML files, namespaces can be specified using the <code>xmlns</code> attribute</li>
<li>Some namespaces are defined with prefixes, and some are defined as default namespaces</li>
<li>Namespaces described on an element apply for that element and all it&#39;s decendant elements. For example</li>
</ul>
<div class="highlight"><pre><code class="xml language-xml" data-lang="xml"><span class="nt">&lt;items</span> <span class="na">xmlns=</span><span class="s">&quot;http://bookschema.com&quot;</span> <span class="na">xmlns:dc=</span><span class="s">&quot;http://purl.org/dc/elements/1.1/&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;book&gt;</span>
    <span class="nt">&lt;title&gt;</span>Trail<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;author</span> <span class="na">xmlns=</span><span class="s">&quot;http://schema.com/person&quot;</span><span class="nt">&gt;</span>
      <span class="nt">&lt;name&gt;</span>Sorrell, Paul<span class="nt">&lt;/name&gt;</span>
      <span class="nt">&lt;title&gt;</span>Mr<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;/author&gt;</span>
    <span class="nt">&lt;dc:identifier&gt;</span>123<span class="nt">&lt;/dc:identifier&gt;</span>
  <span class="nt">&lt;/book&gt;</span>
<span class="nt">&lt;/books&gt;</span>
</code></pre></div>
<p>In this example, there are two different default namespaces, and one namespace with a prefix:
* <code>&lt;items&gt;</code>, <code>&lt;book&gt;</code> and the <code>&lt;title&gt;</code> of the book belong to the vocabulary identified by <code>&quot;http://bookschema.com&quot;</code>
* <code>&lt;author&gt;</code>, <code>&lt;name&gt;</code> and the <code>&lt;title&gt;</code> of a person belong to the vocabulary identified by <code>&quot;http://schema.com/person&quot;</code>
* <code>&lt;dc:identifier&gt;</code> belongs to the vocabulary identified by <code>&quot;http://purl.org/dc/elements/1.1/&quot;</code></p>

<h3 id="toc_1">Namespaces and XPath</h3>

<ul>
<li>Using XPath to select elements from a document requires being specific about which namespaces the elements you are looking for belong to. For example, asking for the XPath <code>//title</code> in the document above could match either the title of a book or the title of a person. </li>
<li>In an XPath expression, default namespaces (ones that have no prefix) are ambiguous, because different default namespaces can be applied to different parts of the document. For this reason all namespaces need a prefix in xpath</li>
<li>Likewise, the prefixes in the document can also be ambiguous because the same prefix can be used to describe multiple namespaces in different parts of the same XML file. </li>
<li>prefixes themselves are only important in context, in XPath we can define our own prefixes to describe the namespaces we mean.</li>
<li>For this reason, an XPath expression is accompanied by a definition of which prefix we want to use to select elements from a particular namespace.</li>
</ul>

<p>Heres an example:</p>

<p>Given the XML above, we choose to define our namespaces for the XPath as:
<code>json
book: &quot;http://bookschema.com&quot;,
dc: &quot;http://purl.org/dc/elements/1.1/&quot;,
person: &quot;http://schema.com/person&quot;
</code>
Now we can use XPath experessions like:
* <code>//book:title</code> selects any titles of books
* <code>//person:title</code> selects any title of a person
* <code>/book:items/book:book/dc:identifier</code> selects the identifier within a book</p>

<h3 id="toc_2">Namespaces in Squirrel Parsers</h3>

<p>To make parsers readable, we want to use a consistant set of namespace prefixes for all the XPath in a parser. To make this easy, a harvest operator defines the namespaces and their prefixes in one place in the parser.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">namespaces</span> <span class="ss">book</span><span class="p">:</span> <span class="s2">&quot;http://bookschema.com&quot;</span><span class="p">,</span>
             <span class="ss">dc</span><span class="p">:</span> <span class="s2">&quot;http://purl.org/dc/elements/1.1/&quot;</span><span class="p">,</span>
         <span class="ss">person</span><span class="p">:</span> <span class="s2">&quot;http://schema.com/person&quot;</span>
</code></pre></div>
<p>With the namespaces defined, all the xpath in the parser can make use of these prefixes.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">record_selector</span> <span class="s1">&#39;/book:items/book:book&#39;</span>

<span class="n">attributes</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">xpath</span><span class="p">:</span> <span class="s1">&#39;/book:title&#39;</span>
<span class="n">attributes</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">xpath</span><span class="p">:</span> <span class="s1">&#39;/person:author/person:name&#39;</span>
<span class="n">attributes</span> <span class="ss">:identifier</span> <span class="k">do</span> 
  <span class="n">fetch</span><span class="p">(</span><span class="s1">&#39;/dc:identifier&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">first</span>
<span class="k">end</span>
</code></pre></div>
<h3 id="toc_3">Tips</h3>

<ul>
<li>To make parsers as strightfoward as possible, it is advisable to use the same prefixes as the XML file, unless the prefix is ambiguous (is used for two different namespaces). For example using &#39;dc&#39; as the prefix for the dublin core schema (&#39;<a href="http://purl.org/dc/elements/1.1/&#x27;">http://purl.org/dc/elements/1.1/&#39;</a>) is common in almost every xml file using this namespace. </li>
<li>Adding common namespaces to parser templates is a good way to reduce the amount of work to create new parsers. For example most OAI feeds use the &#39;<a href="http://purl.org/dc/elements/1.1/">http://purl.org/dc/elements/1.1/</a>&#39; namespace.</li>
</ul>


                    </div>
                
            </div>

            <div class=row-fluid>
                <div id=footer class=span12>
                    Documentation for <a href="https://github.com/DigitalNZ/supplejack_api">Supplejack</a>

                </div>
            </div>
        </div>

        <script>
            function orderNav() {
                var list,
                    section,
                    header,
                    sections = [],
                    lists = {},
                    headers = {};

                var navUl = document.querySelectorAll('#navigation ul')[0],
                    navLis = document.querySelectorAll('#navigation ul li');

                if (!navUl) return;

                for (var i = 0; i < navLis.length; i++) {
                    var order, li = navLis[i];

                    if (li.classList.contains('nav-header')) {
                        section = li.textContent || li.innerText;
                        sections.push(section);
                        headers[section] = li;
                        continue;
                    }

                    if (!lists[section]) {
                        lists[section] = [];
                    }

                    order = parseFloat(li.getAttribute('data-order'))
                    lists[section].push([order, li]);
                }

                for (var i = 0; i < sections.length; i++) {
                    section = sections[i];
                    list = lists[section].sort(function(a, b) {
                        return a[0] - b[0];
                    });

                    if (header = headers[section]) {
                        navUl.appendChild(header);
                    }
                    for (var j = 0; j < list.length; j++) {
                        navUl.appendChild(list[j][1]);
                    }
                }
            }

            if (document.querySelectorAll) orderNav();
        </script>
    </body>
</html>
